<html><head> <title>  
<b>
Turing Machine and its Applications</b>
</title>
<i> Author:: Mandar Mitra<br/>Indian Statistical Institute, Kolkata</i></br> <i> Date:: jan 17 2000</i></br><hr> <body>
<hr><b>
Introduction</b></br>
Turing Machines were first conceived by Turing and described in a paper that appeared in the<i>
Proceedings of the London Mathematical Society</i>
, 1936. Broadly speaking, Turing introduced this model in order to argue that any computer program can be executed on a suitably defined simple machine. The model has proved to be the most widely accepted formal model of computational processes. Before looking at the details of the definition and operation of a Turing Machine, we briefly define some terminology related to the issue of representation.<i>
Representation:</i>
Any<i>
representation</i>
of information, processes, etc. is in terms of certain<i>
symbols</i>
. Rather than attempt to define what a symbol is, we will assume that the notion of a symbol is intuitively clear. Any set of symbols is termed an<i>
alphabet</i>
. A sequence of symbols is called a<i>
string</i>
. A set of strings is called a<i>
language</i>
.<hr><b>
Definition and Operation</b></br>
A good model for computational processes has to have at least two properties. First, the model must be simple enough to allow us to formally reason about computers. Secondly, it must be representative of computers as we know them, i.e. the model must retain the essential features of computers while abstracting away the details. Consider the components of the computers we see around us:<ol> <li> the processing cabinet contains the actual processor ( CPU ) and storage devices ( disks )</li> <li> the keyboard and monitor provide means for conveying data information to and from the computer</li> </ol> Accordingly, the Turing Machine also has a processing unit called the finite control, and an unlimited quantity of tape that simultaneously serves as storage and means for input and output. The finite control can be in one of a finite number of<i>
states</i>
. The tape is divided into squares, each of which can hold a single symbol. Any empty'' square ( i.e. one that has not been written into ) is assumed to hold a special<i>
blank</i>
symbol. A read - write head communicates between the tape and the control: it reads the tape and informs the control of what it has read; it also writes information onto the tape according to the instructions given by the control unit.The machine works as follows: the data that we want to provide as input is written onto the tape, one symbol per square, and the head is positioned at the beginning ( or end, depending on the adopted convention ) of the input. The finite control is put into a designated<i>
initial</i>
state. The machine then starts computation. At each step, the machine reads the symbol in the current tape square, and based on its current state, and the symbol just read, the finite control takes the following actions:<ol> <li> changes to a new state,</li> <li> <ol> <li> either moves the head one square to the left or right,</li> <li> writes a symbol into the current square.</li> </ol> </li> </ol> The machine is expected to eventually change state to a specially designated state called the<i>
halt</i>
state. This signals the end of the computation. Of course, it is also possible that the machine never halts - - - in that case, it does not produce any useful output. Another situation that may arise is that the read - write head of the machine may be on the very first square of the tape, and the finite control may instruct the head to move left. If this does happen, the machine stops operating and is said to<i>
hang</i>
. Note that this is different from halting.<br/>Formally, a Turing Machine can now be defined as follows.<b>
Definition:</b>
A Turing Machine ( TM ) is a quadruple&nbsp;<math>
<mi> [ </mi><mi>Q,</mi><mi>&Sigma;</mi><mi>,</mi><mi>&delta;</mi><mi>,</mi><mi>s</mi><mi> ] </mi></mrow>
</math>
where<br/><table border="0">
<tr>
<td> &nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>1</mn></msub></mrow></mrow>
</math>
 </td> <td>&nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>2</mn></msub></mrow></mrow>
</math>
 </td>
</tr>
<tr>
<td> &nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>1</mn></msub></mrow></mrow>
</math>
 </td> <td>&nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>2</mn></msub></mrow></mrow>
</math>
 </td> <td>&nbsp;<math>
<mi>x</mi>
<mo>=</mo>
<mrow><mfrac>
<mrow>
<mi>(</mi><mi>&alpha;</mi><mi>&beta;</mi><mi>)</mi></mrow>
<mrow>
<mi>&delta;</mi></mrow>
</mfrac></mrow>
</mrow>
</math>
 </td>
</tr>
<tr>
<td> &nbsp;<math>
<mi>&lambda;</mi></mrow>
</math>
 </td> <td>&nbsp;<math>
<mi>&epsilon;</mi></mrow>
</math>
 </td>
</tr>
</table>
<hr><b>
Computing with TMs</b></br>
We now turn to the question of how one can actually use the TM as a computer. TMs can broadly be used in the following ways:<ol> <li> to compute a function from strings to strings: given an input string ( or strings ) , the TM computes a suitable output string;</li> <li> to compute a function from numbers to numbers;</li> <li> to determine whether a given string belongs to a certain language.</li> </ol> Note that most uses of real computers can be classified under ( 1 ) above. Typically, we provide some input data to the computer; this is the input string. The computer computes some result in the form of an output string. In fact, the second and third uses mentioned above can also be regarded as special cases of ( 1 ) . Before actually constructing a TM that can be used to perform some function mentioned above, we need to decide an input output convention. The following convention is commonly adopted: the first square of the tape is left blank, the input string is written into the tape, one symbol per square, starting from the second square, and the head is positioned on the blank square immediately following the input ( see Figure 1 ) . We also require the output to be given on the tape in the same format. We conclude this section with a TM&nbsp;<math>
<mi>M</mi></mrow>
</math>
that computes the following function. Given an input string over the alphabet&nbsp;<math>
<mi>{</mi><mi>a,b</mi><mi>}</mi></mrow>
</math>
, it replaces each&nbsp;<math>
<mi>a</mi></mrow>
</math>
by&nbsp;<math>
<mi>b</mi></mrow>
</math>
and vice versa. Thus, given&nbsp;<math>
<mi>aab</mi></mrow>
</math>
as input,&nbsp;<math>
<mi>M</mi></mrow>
</math>
produces&nbsp;<math>
<mi>bba</mi></mrow>
</math>
as output. The formal construction of&nbsp;<math>
<mi>M</mi></mrow>
</math>
will consist of specifying the quadruple&nbsp;<math>
<mi> [ </mi><mi>Q,</mi><mi>&Sigma;</mi><mi>,</mi><mi>&delta;</mi><mi>,</mi><mi>s</mi><mi> ] </mi></mrow>
</math>
that makes up&nbsp;<math>
<mi>M</mi></mrow>
</math>
.&nbsp;<math>
<mi>M</mi></mrow>
</math>
is thus given by:&nbsp;<math>
<mi>s</mi>
<mo>=</mo>
<mrow><msub>
<mi>q</mi><mn>0</mn></msub></mrow></mrow>
</math>
<br/>&nbsp;<math>
<mi>&delta;</mi><mi>:</mi></mrow>
</math>
<hr><b>
Extensions</b></br>
Apart from the basic model described above, certain extended versions of Turing Machines have also been studied. Some of the extensions to the Turing Machine model that have been investigated are: ( i ) allowing several tapes instead of just one; ( ii ) allowing several heads on the tape instead of just one; ( iii ) allowing the tape to be two - dimensional ( i.e. like a page ) instead of one - dimensional ( linear ) . It has been found that these extensions sometimes make computation easier or more efficient. For example, it may be easier to construct a 2 - tape or 3 - tape machine for solving certain problems. However, it can be proved that the standard model can imitate or simulate the operation of any extended model proposed till date. In other words, any function that can be computed by an extended model can also be computed by the basic model. Of course, the basic model may require a larger number of steps to do the computation.<hr><b>
Universal Turing Machine</b></br>
The only example TM that we have considered above performs a fairly elementary operation. If Turing Machines are to be more convincing as a good model for real - life computers, we should be able to construct a general - purpose Turing Machine that is capable of running any program''. The Universal Turing Machine ( UTM ) is precisely this sort of a TM: it takes a particular program and input data, and runs the program on the given data. Formally, a program is represented by a suitable TM that performs the function of that program. In order to provide a TM as one of the inputs to the UTM, we need to be able to represent any TM by a string. For this purpose, we assume that there are two ( countably infinite ) sets&nbsp;<math>
<mrow><msub>
<mi>Q</mi><mi>&inf;</mi></msub></mrow></mrow>
</math>
and&nbsp;<math>
<mrow><msub>
<mi>&Sigma;</mi><mi>&inf;</mi></msub></mrow></mrow>
</math>
containing, respectively, all the state and alphabet symbols that we ever need:&nbsp;<math>
<mrow><msub>
<mi>Q</mi><mi>&inf;</mi></msub></mrow>
<mo>=</mo>
<mi>{</mi><mrow><msub>
<mi>q</mi><mi>1,</mi></msub></mrow><mrow><msub>
<mi>q</mi><mi>2,</mi></msub></mrow><mi>}</mi></mrow>
</math>
We now choose a specific symbol, say&nbsp;<math>
<mi>I</mi></mrow>
</math>
, and represent all elements of&nbsp;<math>
<mi>Q</mi></mrow>
</math>
and&nbsp;<math>
<mi>&Sigma;</mi></mrow>
</math>
, as well as&nbsp;<math>
<mi>h,</mi><mi>L,</mi><mi>R</mi></mrow>
</math>
by strings of&nbsp;<math>
<mi>I</mi></mrow>
</math>
s. For example,&nbsp;<math>
<mi>h</mi></mrow>
</math>
could be represented as&nbsp;<math>
<mi>I</mi></mrow>
</math>
,&nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>1</mn></msub></mrow></mrow>
</math>
as&nbsp;<math>
<mi>II</mi></mrow>
</math>
,&nbsp;<math>
<mrow><msub>
<mi>q</mi><mn>2</mn></msub></mrow></mrow>
</math>
as&nbsp;<math>
<mi>III</mi></mrow>
</math>
and so on. Likewise,&nbsp;<math>
<mi>L</mi></mrow>
</math>
could be represented as&nbsp;<math>
<mi>I</mi></mrow>
</math>
,&nbsp;<math>
<mi>R</mi></mrow>
</math>
as&nbsp;<math>
<mi>II</mi></mrow>
</math>
,&nbsp;<math>
<mrow><msub>
<mi>a</mi><mn>1</mn></msub></mrow></mrow>
</math>
as&nbsp;<math>
<mi>III</mi></mrow>
</math>
, etc. If we now choose a second symbol, say&nbsp;<math>
<mn>0</mn></mrow>
</math>
, and use it as a separator symbol, we can represent a specific TM&nbsp;<math>
<mi>M</mi>
<mo>=</mo>
<mi> [ </mi><mi>Q,</mi><mi>&Sigma;</mi><mi>,</mi><mi>&delta;</mi><mi>,</mi><mi>s</mi><mi> ] </mi></mrow>
</math>
using the above - mentioned convention for representing each individual state and symbol. Let us denote this string representation of&nbsp;<math>
<mi>M</mi></mrow>
</math>
as&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
. We can now informally outline the construction of a TM,&nbsp;<math>
<mi>U</mi></mrow>
</math>
with 4 tapes that works as a UTM. In other words, given a TM and a string as input, both encoded using the above scheme,&nbsp;<math>
<mi>U</mi></mrow>
</math>
simulates the given TM on the given string, and produces the desired output ( also encoded using the same scheme ) .&nbsp;<math>
<mi>U</mi></mrow>
</math>
starts with encoded representations of an input TM ( say&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
) and string ( say&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>w</mi><mi>)</mi></mrow>
</math>
) on the first tape. The other tapes are blank.&nbsp;<math>
<mi>U</mi></mrow>
</math>
first copies&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
onto the second tape, and&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>w</mi><mi>)</mi></mrow>
</math>
onto the third tape. From&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
, it extracts and copies the string representing the initial state onto the fourth tape.&nbsp;<math>
<mi>U</mi></mrow>
</math>
now simulates each step of&nbsp;<math>
<mi>M</mi></mrow>
</math>
. During the simulation, the 4 tapes are used as follows: tape 1 always holds the original input (&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
and&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>w</mi><mi>)</mi></mrow>
</math>
) , tape 2 stores&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
, tape 3 is used to represent&nbsp;<math>
<mi>M</mi></mrow>
</math>
's tape, and tape 4 stores the current state and input symbol of&nbsp;<math>
<mi>M</mi></mrow>
</math>
. More specifically,&nbsp;<math>
<mi>U</mi></mrow>
</math>
copies the input symbol currently being read by&nbsp;<math>
<mi>M</mi></mrow>
</math>
from tape 3 to tape 4. It now looks for an entry for the current state and input symbol pair in the transition function of&nbsp;<math>
<mi>M</mi></mrow>
</math>
stored on tape 2. This entry specifies the new state and a suitable action. The new state is recorded on tape 4, and tape 3 is modified in accordance with the specified action. Thus, it is easy to see that&nbsp;<math>
<mi>U</mi></mrow>
</math>
needs several steps to simulate one step of&nbsp;<math>
<mi>M</mi></mrow>
</math>
. This process continues, and when&nbsp;<math>
<mi>M</mi></mrow>
</math>
halts, the output produced by&nbsp;<math>
<mi>M</mi></mrow>
</math>
can be found on tape 3.<hr><b>
Undecidability</b></br>
We now come to the question of what a computer can or cannot compute. Specifically, we consider the following problem: is it possible to say, given any TM&nbsp;<math>
<mi>M</mi></mrow>
</math>
, and input string&nbsp;<math>
<mi>w</mi></mrow>
</math>
, whether&nbsp;<math>
<mi>M</mi></mrow>
</math>
will halt on&nbsp;<math>
<mi>w</mi></mrow>
</math>
? Suppose we assume that it is indeed possible to write a program&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>0</mn></msub></mrow></mrow>
</math>
that answers this question for any given&nbsp;<math>
<mi>M</mi></mrow>
</math>
and&nbsp;<math>
<mi>w</mi></mrow>
</math>
. Then it must also be possible to write a program&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
that answers the following question:&nbsp;<math>
<mi>M</mi></mrow>
</math>
&nbsp;<math>
<mi>M</mi></mrow>
</math>
&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
&nbsp;<math>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
&nbsp;<math>
<mi>M</mi></mrow>
</math>
&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
takes its input&nbsp;<math>
<mi>M</mi></mrow>
</math>
, constructs the string&nbsp;<math>
<mi>w</mi>
<mo>=</mo>
<mi>enc</mi><mi>(</mi><mi>M</mi><mi>)</mi></mrow>
</math>
, and passes&nbsp;<math>
<mi>M,w</mi></mrow>
</math>
to program&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>0</mn></msub></mrow></mrow>
</math>
.&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
returns to the user whatever answer it gets from&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>0</mn></msub></mrow></mrow>
</math>
. Now, we construct a program&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
which works as follows: given an input&nbsp;<math>
<mi>w</mi></mrow>
</math>
,&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
first passes the input to&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
. If the answer returned by&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
is no'',&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
prints this on the screen and stops. If the answer returned by&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
is yes'', then&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
intentionally goes into an infinite loop, so it never stops. Since&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
is a program, we can construct a Turing Machine&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
that performs the same function as&nbsp;<math>
<mrow><msub>
<mi>P'</mi><mn>1</mn></msub></mrow></mrow>
</math>
. Now consider what happens when&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
is run on&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
.&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
will first pass&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
to&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
( or an equivalent TM ) . If&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
halts on&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
, then&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
answers yes'', so&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
goes into an infinite loop and does not halt. Conversely, if&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
does not halt on&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
, then&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>1</mn></msub></mrow></mrow>
</math>
answers no'', so&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
writes this on the output tape and halts. In summary, if&nbsp;<math>
<mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow></mrow>
</math>
halts on&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
, then it does not halt on&nbsp;<math>
<mi>enc</mi><mi>(</mi><mrow><msub>
<mi>M'</mi><mn>1</mn></msub></mrow><mi>)</mi></mrow>
</math>
, and vice versa. This is a contradiction. Thus, the assumption that it is possible to write the program&nbsp;<math>
<mrow><msub>
<mi>P</mi><mn>0</mn></msub></mrow></mrow>
</math>
must have been mistaken. In other words, there is no Turing Machine ( or equivalently, no program ) that can tell, given another program and some input data, whether the latter will halt on the given input. This is arguably the most important application of Turing Machines: using a formal model, one is able to prove that there is a concrete problem that cannot be solved using computers. Using this problem, it is possible to show that certain other problems, encountered in real - life situations, are also unsolvable. The interested reader can refer tofor more details.<hr> <b>The References</b></br><ol> <li> <i>
Elements of the Theory of Computation</i>
. H.R. Lewis and C.H. Papadimitriou, Prentice - Hall Inc., 1981.</li> </ol> </body>
</html> 
